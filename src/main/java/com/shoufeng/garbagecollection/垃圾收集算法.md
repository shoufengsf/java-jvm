# 垃圾收集算法

## 标记-清除算法

​      该算法如同它的名字一样，分为两个阶段：**标记**、**清除**。首先标记出所有需要回收的对象，然后，统一清除这些被标记的对象。

**缺点**：

1、**效率不高**；

2、产生大量不连续的内存碎片，导致有大量内存剩余的情况下，由于，**没有连续的空间来存放较大的对象**，从而触发了**另一次垃圾收集动作**。

![](.\images\标记清除算法.png)

## 复制算法

​      由于标记-清除算法的效率不高，从而提出了复制算法。复制算法将可用的内存分成两样大小的两块，每次**只使用其中一块内存**。当这块内存用完之后，就把还**存活**的对象**复制**到**另外一块**上面，然后，把这块清空。复制算法克服了标记-清除算法的两个缺点，但是**太浪费内存**，相当于内存空间减小了一半。
​      随着时间的积累，现在使用的复制算法的虚拟机，不再是把内存分为1：1的两块。因为98%的对象是寿命很短的，创建之后，很快就被回收了，存活下来的只有2%，所以，用来存储存活对象的内存区，可以小一些。现在的商业虚拟机是把可用内存分为**一个**较大的**Eden**空间和**两个**较小的**Survivor**空间，**每次**使用**Eden**和**其中的一块Survivor**。当**回收**时，把Eden和Survivor中的存活对象一次**复制**到**另一块Survivor**内存区上，然后把Eden和刚才用过的Survivor空间**清空**。HotSpot虚拟机默认Eden和Survivor的大小比例是**8：1**，这样，每次新产生的对象可以使用90%的内存空间。

当**Survivor空间不够**时，需要依赖其他内存（这里指**老年代**）进行**分配担保**（Handle promotion）。

**内存分配**

内存分配是在JVM在内存分配的时候，**新生代内存不足**时，**把新生代的存活的对象搬到老生代**，然后新生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。在**Serial+Serial Old**的情况下，发现放不下就**直接启动担保机制**；在**Parallel Scavenge+Serial Old**的情况下，却是先要去判断一下要分配的内存是不是**>=Eden区大小的一半**，如果是那么直接把该对象放入老生代，否则才会启动担保机制。

![](.\images\复制算法.png)

## 标记-整理算法（老年代）

​      从名字可以看出，该算法是对“标记-清除”算法的改进升级版。同样的该算法分为两个阶段：标记、整理。标记阶段同“标记-清除”算法。整理阶段，不是直接对标记对象进行清理，而是让所有存活的对象都移动到一端，然后，直接把边界以外的内存清空。这就解决了“标记-清除”算法会造成大量不连续内存碎片的问题。

![](.\images\标记整理算法.png)

## 分代收集算法

​      分代收集算法是根据对象的存活周期的不同，将内存划分为几块。当前的商业虚拟机的垃圾收集都采用了该算法。一般把Java堆分成新生代（年轻代）和老年代（年老代）。这样就可以根据各年代中对象的存活周期来选择最合适的收集算法了。**新生代**，由于只有少量的对象能存活下来，所以选用“**复制算法**”，只需要付出少量存活对象的复制成本。**老年代**，由于对象的存活率高，没有额外的空间分担，就必须使用“**标记-清除**”或“**标记-整理**”算法。


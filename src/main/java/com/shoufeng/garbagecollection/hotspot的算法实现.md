# HotSpot的算法实现

## 枚举根节点

从**可达性分析**中从GC Roots节点找到引用链这个操作为例，可作为GC Roots的**节点**主要在**全局性的引用**（例如常量或类静态属性）与**执行上下文**（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查里面的引用，必然会消耗很多时间。

另外可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确**保一致性的快照**中进行，这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被**冻结在某个时间点上**，不可以出现分析过程中对象引用还在不断变化的情况，该点不满足的话分析结果准确性就无法保证。这就是导致**Stop The World**的其中一个重要原因，即使在号称不会发生停顿的**CMS收集器**中，**枚举根节点**时也是**必须要停顿**的。

当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知那些地方存放着对象引用。利用**OopMap**的数据结构达到这个目的，类加载完后，把**对象内什么偏移量**上是**什么类型的数据**计算出来，在JIT编译过程中，也会在**特定的位置**记录下**栈和寄存器**中哪些位置是**引用**。

## 安全点

程序执行时并非所有地方都能停顿下来进行GC，只有到达安全点才能暂停。**安全点的选定**基本上是以程序“**是否具有让程序长时间执行的特征**”为标准进行。“长时间执行”的**最明显特征**就是**指令复用**，例如**方法调用**、**循环跳转**、**异常跳转**等，所以具有这些功能的指令才会产生SafePoint。

**抢先式中断**（几乎没有虚拟机采用）：在**GC发生时**，首先把所有线程全部中断，如果发现有线程中断的地方**不在安全点上**，就**恢复**线程，让他**跑到安全点**上。

**主动式中断**：当GC需要中断线程时，不直接对线程操作，仅仅简单的**设置一个标志**，各个**线程**执行时**主动去轮询**这个标志，发现中断标志**为真**时就自己**中断挂起**。**轮询标志**的地方是和**安全点重合**的。

## 安全区域

Safe Region看作被扩展了的Safe Point。

